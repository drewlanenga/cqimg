// Generated by CoffeeScript 1.6.3
var chars, charts, colors, d3, fs, months, props, svg2png;

d3 = require("d3");

fs = require("fs");

svg2png = require("svg2png");

colors = {
  primary: {
    black: "#0d0a0b",
    grey: "#454955",
    white: "#f3eff5",
    brightgreen: "#72b01d",
    darkgreen: "#3f7d20"
  }
};

props = {
  titleHeight: 36,
  footerHeight: 24,
  xmlprefix: '<?xml version="1.0" encoding="UTF-8"?>'
};

chars = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];

months = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];

charts = {
  formatDate: function(d) {
    return "" + (d.getDate()) + " " + (months[d.getMonth()].toUpperCase()) + " " + (d.getFullYear());
  },
  random: function(nchar) {
    var i, sample, _i;
    sample = [];
    for (i = _i = 0; 0 <= nchar ? _i < nchar : _i > nchar; i = 0 <= nchar ? ++_i : --_i) {
      sample.push(chars[Math.floor(Math.random() * chars.length)]);
    }
    return sample.join('');
  },
  write: function(xml, svgfile, pngfile, dpi, callback) {
    fs.writeFileSync(svgfile, xml);
    return svg2png(svgfile, pngfile, dpi, callback);
  },
  draw: function(config, method, params) {
    var chartFooter, chartHeader, chartTitleBox, footerDate, footerLogo, guts, height, metaStuff, svg, topPadding, totalHeight, width;
    metaStuff = {
      title: params.title,
      subtitle: params.subtitle,
      headerHeight: 120,
      footerHeight: 50,
      dates: {
        start: new Date("" + params.startDate + " 10:00:00"),
        end: new Date("" + params.endDate + " 10:00:00")
      }
    };
    width = config.w - config.padding * 2;
    height = config.h - config.padding * 2;
    totalHeight = config.h;
    if (params.includeHeader) {
      totalHeight += metaStuff.headerHeight;
    }
    if (params.includeFooter) {
      totalHeight += metaStuff.footerHeight;
    }
    svg = d3.select("body").html("").append("svg").attr("width", config.w).attr("height", totalHeight).attr("viewBox", "0 0 " + config.w + " " + totalHeight).attr("xmlns", "http://www.w3.org/2000/svg").attr("xmlns:xlink", "http://www.w3.org/1999/xlink").style("font-family", "Raleway, Arial, sans-serif");
    topPadding = config.padding;
    if (params.includeHeader) {
      topPadding += metaStuff.headerHeight;
      chartHeader = svg.append("g").attr("class", "chart-header").attr("width", width).attr("height", metaStuff.headerHeight).attr("transform", "translate(" + config.padding + ", " + config.padding + ")");
      if (params.includeBumpers) {
        chartHeader.append("rect").attr("class", "bg").attr("width", width).attr("height", metaStuff.headerHeight).style("fill", "#996699").style("opacity", 0.7);
      }
      chartTitleBox = chartHeader.append("text").attr("class", "chart-titlebox").attr("dy", "1em");
      chartTitleBox.append("tspan").attr("class", "chart-title").attr("text-anchor", "start").attr("dy", "1em").style("fill", colors.primary.black).style("font-size", "28pt").text(metaStuff.title);
      chartTitleBox.append("tspan").attr("class", "chart-subtitle").attr("text-anchor", "start").attr("x", 0).attr("dy", "2em").style("fill", colors.primary.grey).style("font-size", "14pt").text(metaStuff.subtitle);
    }
    guts = svg.append("g").attr("class", "chart-guts").attr("width", width).attr("height", height).attr("transform", "translate(" + config.padding + ", " + topPadding + ")");
    if (params.includeBumpers) {
      guts.append("rect").attr("class", "bg").attr("width", width).attr("height", height);
    }
    if (params.includeFooter) {
      chartFooter = svg.append("g").attr("class", "chart-footer").attr("width", width).attr("height", metaStuff.footerHeight).attr("transform", "translate(" + config.padding + ", " + (topPadding + height) + ")");
      if (params.includeBumpers) {
        chartFooter.append("rect").attr("class", "bg").attr("width", width).attr("height", metaStuff.footerHeight).style("fill", '#669966').style('opacity', 0.8);
      }
      footerLogo = chartFooter.append("text").attr('class', 'footer-logo').attr('y', metaStuff.footerHeight).style('fill', colors.primary.darkgreen);
      footerLogo.append('tspan').text('CULTURE');
      footerLogo.append('tspan').style('font-weight', '700').text('QUANT');
      footerLogo.append('tspan').text('.CO');
      footerDate = chartFooter.append('text').attr('class', 'footer-dates').attr('y', metaStuff.footerHeight).attr('x', width).attr('text-anchor', 'end').style('fill', colors.primary.grey).style('font-size', '10pt');
      footerDate.append('tspan').text('DATA FOR ');
      footerDate.append('tspan').style('font-weight', 500).text(charts.formatDate(metaStuff.dates.start));
      footerDate.append('tspan').text(' - ');
      footerDate.append('tspan').style('font-weight', 500).text(charts.formatDate(metaStuff.dates.end));
    }
    method(config, guts);
    return props.xmlprefix + d3.select('body').html();
  },
  createLogo: function(ctx) {
    return ctx.append("g").attr("class", "chart-logo");
  },
  collaboration: function(config, ctx) {
    var arcGroup, calcArc, centers, chartData, circleGroup, entities, height, i, innerDistance, labelHeight, padding, team, width, _i, _ref;
    chartData = config.chartData;
    padding = {
      h: 60,
      v: 20
    };
    labelHeight = 46;
    height = ctx.attr("height");
    width = ctx.attr("width") - padding.h * 2;
    innerDistance = width / (chartData.nodes.length - 1);
    centers = {};
    for (i = _i = 0, _ref = chartData.nodes.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      team = chartData.nodes[i];
      centers[team.id] = (innerDistance * i) + padding.h;
    }
    calcArc = function(d, i) {
      var arc, from, fromX, to, toX, val, x1, x2, y;
      from = d.from;
      to = d.to;
      fromX = centers[from];
      toX = centers[to];
      x1 = fromX;
      x2 = toX;
      if (fromX > toX) {
        x1 = toX;
        x2 = fromX;
      }
      y = height - padding.v - labelHeight;
      val = 40;
      arc = "M " + x1 + "," + y + " A " + val + "," + (parseInt(val / 1.25)) + " 0 1 1 " + x2 + "," + y;
      return arc;
    };
    arcGroup = ctx.append("g").attr("class", "arc-group").attr("transform", "translate(0, 0)").style("fill", "rgba(255, 255, 255, 0)");
    arcGroup.selectAll("path").data(chartData.edges).enter().append("path").attr("stroke", colors.primary.darkgreen).attr("stroke-width", function(d, i) {
      return d.explore * 2;
    }).attr("d", calcArc).style("opacity", 0.8);
    circleGroup = ctx.append("g").attr("class", "circle-group");
    entities = circleGroup.selectAll("g.entity").data(chartData.nodes).enter().append("g").attr("class", "entity").attr("cx", function(d, i) {
      return centers[d.id];
    });
    entities.append("circle").attr("cx", function(d, i) {
      return centers[d.id];
    }).attr("cy", height - padding.v - labelHeight).attr("r", function(d, i) {
      return Math.sqrt(d.engage) * 2;
    }).attr("nodeid", function(d) {
      return d.id;
    }).attr("stroke", "#FFFFFF").attr("stroke-width", 2).style("fill", colors.primary.grey);
    return entities.append("text").attr("text-anchor", "middle").attr("x", function(d) {
      return centers[d.id];
    }).attr("y", height - padding.v).text(function(d) {
      return d.name;
    });
  },
  radar: function(config, ctx) {
    var allAxis, axis, calcXY, height, j, labels, nticks, padding, radians, radius, series, tickFactor, total, width, xy, _i;
    allAxis = config.chartData.radar.actual;
    total = allAxis.length;
    radians = 2 * Math.PI;
    nticks = 5;
    padding = 0;
    height = ctx.attr("height") - (padding * 2);
    width = ctx.attr("width") - (padding * 2);
    radius = Math.min(height, width) / 3;
    xy = function(factor, i, op) {
      return factor * (1 - op(i * radians / total));
    };
    calcXY = function(percentageOfMax, maxLength, percentRadian, op) {
      return op(percentRadian * radians) * maxLength * percentageOfMax;
    };
    ctx = ctx.append("g").attr("width", width).attr("height", height).attr("class", "spider-axis").attr("transform", "translate(0, 0)");
    tickFactor = 0;
    for (j = _i = 1; 1 <= nticks ? _i <= nticks : _i >= nticks; j = 1 <= nticks ? ++_i : --_i) {
      tickFactor = j / nticks;
      ctx.selectAll(".levels").data(allAxis).enter().append("svg:line").attr("x1", function(d, i) {
        return -calcXY(tickFactor, radius, i / total, Math.sin);
      }).attr("y1", function(d, i) {
        return -calcXY(tickFactor, radius, i / total, Math.cos);
      }).attr("x2", function(d, i) {
        return -calcXY(tickFactor, radius, (i + 1) / total, Math.sin);
      }).attr("y2", function(d, i) {
        return -calcXY(tickFactor, radius, (i + 1) / total, Math.cos);
      }).attr("class", "line").attr("transform", "translate(" + (width / 2) + "," + (height / 2) + ")").style('stroke', colors.primary.grey).style('stroke-opacity', 0.75).style('stroke-width', '0.3px');
    }
    series = 0;
    axis = ctx.selectAll(".axis").data(allAxis).enter().append("g").attr("class", "axis");
    axis.append("line").attr("x1", width / 2).attr("y1", height / 2).attr("x2", function(d, i) {
      return width / 2 - calcXY(1.05, radius, i / total, Math.sin);
    }).attr("y2", function(d, i) {
      return height / 2 - calcXY(1.05, radius, i / total, Math.cos);
    }).attr("class", "line").style("stroke-width", "3px").style('stroke', colors.primary.black);
    labels = axis.append("text").attr("class", "legend").attr("text-anchor", "middle").attr("dy", "1.5em").attr("transform", "translate(0, -24)").attr("x", function(d, i) {
      return width / 2 - calcXY(1.3, radius, i / total, Math.sin);
    }).attr("y", function(d, i) {
      return height / 2 - calcXY(1.3, radius, i / total, Math.cos);
    });
    labels.append("tspan").attr("class", "axis-label").attr("text-anchor", "middle").attr("dy", "1.2em").attr("x", function(d, i) {
      return width / 2 - calcXY(1.3, radius, i / total, Math.sin);
    }).text(function(d) {
      return d.name.toUpperCase();
    });
    labels.append("tspan").attr("class", "axis-value").attr("text-anchor", "middle").attr("dy", "1.2em").attr("x", function(d, i) {
      return width / 2 - calcXY(1.3, radius, i / total, Math.sin);
    }).text(function(d) {
      return d.value;
    }).style('font-weight', 700);
    charts.drawPolygons(ctx, config.chartData.radar.benchmark, "radar-chart-benchmark", width, height, radius, total, calcXY, colors.primary.grey);
    return charts.drawPolygons(ctx, config.chartData.radar.actual, "radar-chart-actual", width, height, radius, total, calcXY, colors.primary.darkgreen);
  },
  drawPolygons: function(ctx, chartData, className, width, height, radius, total, calcXY, color) {
    var dataValues, pushValue;
    dataValues = [];
    pushValue = function(j, i) {
      return [width / 2 - calcXY(j.value / 100, radius, i / total, Math.sin), height / 2 - calcXY(j.value / 100, radius, i / total, Math.cos)];
    };
    ctx.selectAll(".nodes").data(chartData, function(j, i) {
      return dataValues.push(pushValue(j, i));
    });
    dataValues.push(dataValues[0]);
    return ctx.selectAll(".area").data([dataValues]).enter().append("polygon").attr("class", className).attr("points", function(d) {
      var pointi, str, _i, _ref;
      str = "";
      for (pointi = _i = 0, _ref = d.length; 0 <= _ref ? _i < _ref : _i > _ref; pointi = 0 <= _ref ? ++_i : --_i) {
        str += d[pointi][0] + ", " + d[pointi][1] + " ";
      }
      return str;
    }).style('stroke-width', '2px').style('stroke', color).style('fill', color).style('fill-opacity', 0.5);
  },
  karma: function(config, ctx) {
    var calcR, cellHeight, cellWidth, coords, entities, getIJ, gridHeight, gridWidth, height, i, ij, karmaArea, karmaData, karmaRadius, labels, maxKarma, ncol, npeople, nrow, padding, width, _i;
    karmaData = config.chartData.karma;
    padding = {
      w: 0,
      h: 20
    };
    height = ctx.attr("height") - (padding.h * 2);
    width = ctx.attr("width") - (padding.w * 2);
    npeople = Math.min(karmaData.length, config.chartData.maxKarmaDims.rows * config.chartData.maxKarmaDims.cols);
    ncol = Math.ceil(Math.max(config.chartData.maxKarmaDims.cols, npeople) / config.chartData.maxKarmaDims.rows);
    nrow = Math.ceil(npeople / ncol);
    karmaData.splice(npeople);
    gridHeight = height;
    gridWidth = width;
    cellWidth = gridWidth / ncol;
    cellHeight = gridHeight / nrow;
    getIJ = function(index, nrows, ncols) {
      var i, j;
      j = index % ncols;
      i = Math.floor(index / ncols);
      return {
        i: i,
        j: j
      };
    };
    karmaRadius = Math.min(gridHeight / nrow, gridWidth / ncol) * 0.4;
    karmaArea = Math.PI * Math.pow(karmaRadius, 2);
    calcR = function(area) {
      return Math.sqrt(area / Math.PI);
    };
    maxKarma = 0;
    coords = [];
    for (i = _i = 0; 0 <= npeople ? _i < npeople : _i > npeople; i = 0 <= npeople ? ++_i : --_i) {
      if (karmaData[i].value > maxKarma) {
        maxKarma = karmaData[i].value;
      }
      ij = getIJ(i, nrow, ncol);
      coords.push({
        x: (ij.j / ncol * gridWidth) + (cellWidth / 2) + padding.w,
        y: (ij.i / nrow * gridHeight) + (cellHeight / 3) + padding.h
      });
    }
    entities = ctx.selectAll("g.entity").data(karmaData).enter().append("g").attr("class", "entity").attr("cx", function(d, i) {
      return coords[i].x;
    });
    entities.append("circle").attr("class", "karma-circle").attr("cx", function(d, i) {
      return coords[i].x;
    }).attr("cy", function(d, i) {
      return coords[i].y;
    }).attr("r", function(d, i) {
      return calcR(d.value / maxKarma * karmaArea);
    }).style('stroke', '#FFFFFF').style('stroke-width', 2).style('fill', colors.primary.grey);
    labels = entities.append("text").attr("x", function(d, i) {
      return coords[i].x;
    }).attr("y", function(d, i) {
      return coords[i].y + karmaRadius;
    });
    labels.append("tspan").attr("class", "axis-label").attr("text-anchor", "middle").attr("dy", "1.2em").attr("x", function(d, i) {
      return coords[i].x;
    }).text(function(d, i) {
      return d.name;
    });
    return labels.append("tspan").attr("class", "axis-value").attr("text-anchor", "middle").attr("dy", "1.2em").attr("x", function(d, i) {
      return coords[i].x;
    }).text(function(d, i) {
      return d.value;
    }).style('font-weight', 700);
  },
  bars: function(config, ctx) {
    var barData, barWidth, columnOffset, columnPadding, columnWidth, g, height, i, imgs, labelWidth, ncolumns, rowHeight, rowPadding, rows, titleHeight, totalColumnPadding, width, _i, _ref, _results;
    barData = config.chartData.bars;
    titleHeight = 40;
    height = ctx.attr("height") - titleHeight;
    width = ctx.attr("width");
    ncolumns = config.chartData.bars.length;
    totalColumnPadding = width * 0.1;
    columnPadding = totalColumnPadding / (ncolumns - 1);
    columnWidth = (width - totalColumnPadding) / ncolumns;
    labelWidth = 140;
    barWidth = columnWidth - labelWidth;
    _results = [];
    for (i = _i = 0, _ref = barData.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      columnOffset = (columnWidth + columnPadding) * i;
      rowHeight = height / (barData[i].bars.length + 1);
      rowPadding = rowHeight * 0.1;
      g = ctx.append("g").attr("x", columnOffset).attr("y", 0);
      g.append("text").attr("class", "column-label").attr("x", columnOffset + labelWidth).attr("y", titleHeight).text(barData[i].name);
      rows = g.selectAll("g.bar-row").data(barData[i].bars).enter().append("g").attr("class", "bar-row").attr("height", rowHeight);
      rows.append("rect").attr("class", "bar").attr("x", columnOffset + labelWidth).attr("y", function(d, i) {
        return (i + 1) * rowHeight + rowPadding;
      }).attr("width", function(d, i) {
        return d.value / 100 * barWidth;
      }).attr("height", rowHeight - rowPadding * 2).style('fill', colors.primary.grey);
      rows.append("text").attr("class", "bar-label").attr("x", columnOffset).attr("y", function(d, i) {
        return ((i + 1) * rowHeight) + (rowHeight / 2);
      }).text(function(d) {
        return d.name;
      }).style('alignment-baseline', 'mathematical').style('text-anchor', 'start');
      rows.append("text").attr("class", "bar-value").attr("x", columnOffset + labelWidth + rowPadding).attr("y", function(d, i) {
        return ((i + 1) * rowHeight) + (rowHeight / 2);
      }).text(function(d) {
        return d.value;
      }).style('fill', '#FFFFFF').style('text-anchor', 'start').style('alignment-baseline', 'mathematical').style('font-weight', '500');
      _results.push(imgs = rows.append("svg:image").attr("class", "headshot").attr("xlink:href", function(d) {
        return "headshots/" + d.id + ".png";
      }).attr("x", columnOffset + labelWidth - rowHeight).attr("y", function(d, i) {
        return (i + 1) * rowHeight;
      }).attr("width", rowHeight).attr("height", rowHeight));
    }
    return _results;
  }
};

module.exports = charts;
